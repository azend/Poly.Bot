using Direct = System.IO.Directory;

class RepoInfo {
	Name = 'Poly';
	Owner = 'scoizzle';
	Channel = '#scoizzle';
	AccessToken = '1e4d005f6be64eeaa64e454cfc3cd7c66923394a';

	function RepoInfo(Name, Owner, Channel, Token) {
		this.Name = Name;
		this.Owner = Owner;
		this.Channel = Channel;

		if (Token)
			this.AccessToken = Token;
	}
}

class Poly.Bot.Github : Poly.Bot.Module {
	function Github() {
		this.Module("Github");
		
		this.AccessToken = ;
		this.CommitTemplate = 'Commit by {commit.author.name}, {sha}\r\n{commit.message}';
	}

	function Init(Bot) {
		if (!Bot.GithubConfigPath) {
			Log.Error('No GithubConfigPath specified for ' + Bot.Ident);
			return;
		}

		Bot.GithubConfig = Load(Bot.GithubConfigPath + 'Repos.json');

		if (!Bot.GithubConfig) {
			Bot.GithubConfig = [ ];
			this.SaveConfig(Bot);
		}

		Bot.On('Connected', this.InitLoop);

		Cmd = this.GetHandler("Cmd");
		Cmd.On('!git->add {Owner} {Repo} {Target}', this.AddRepo);
	}

	function SaveConfig(Bot) {
		if (!Bot.GithubConfigPath) {
			Log.Error('No GithubConfigPath specified for ' + Bot.Ident);
			return;
		}

		Bot.GithubConfig.Save(Bot.GithubConfigPath + 'Repos.json');
	}

	function GetRepoPath(Bot, Repo) {
		return Bot.GithubConfigPath + Repo.Owner + '.' + Repo.Name + '/';
	}
	
	function Poll(Url, AccessToken) {
		Headers = { 'User-Agent': 'Poly.Bot.Github' };

		if (AccessToken) {
			Headers.Authorization = 'token ' + AccessToken;
		}

		Url = Http.Escape(Url);
		Result = Http.Get('https://api.github.com' + Url, Headers);
		Result = Result.ToObject();

		return Result;
	}

	function PollCommits(Owner, Repo, AccessToken) {
		Result = this.Poll('/repos/' + Owner + '/' + Repo + '/commits', AccessToken);
		return Result;
	}

	function PollIssues(Owner, Repo, AccessToken) {
		Result = this.Poll('/repos/' + Owner + '/' + Repo + '/issues', AccessToken);
		return Result;
	}

	function DoPollingLoop(Bot) {
		while (Bot.Connected) {
			foreach (Repo in Bot.GithubConfig) {
				Repo = Repo.Value;
				RepoPath = this.GetRepoPath(Bot, Repo);
				Commits = this.PollCommits(Repo.Owner, Repo.Name, Repo.AccessToken);

				if (Commits.message) {
					Log.Error(Commits.message);
					break;
				}

				if (Commits) {
					Commits.Save(RepoPath + 'Commits.json');

					Latest = Commits[0];

					if (Latest.sha != Repo.LastKnownSha) {
						foreach (Item in Commits) {
							Com = Item.Value;

							if (Com.sha == Repo.LastKnownSha)
								break;

							Bot.SendMessage(Repo.Channel, Com.Template(this.CommitTemplate));						
						}
					}

					Repo.LastKnownSha = Latest.sha;
					this.SaveConfig(Bot);
				}

				Issues = this.PollIssues(Repo.Owner, Repo.Name, Repo.AccessToken);

				if (Issues) {
				}
			}

			Sleep(30000);
		}
	}

	function InitLoop() {
		Mod = GetModule('Github');
		async Mod.DoPollingLoop(this);
	}

	function AddRepo() {
		Mod = GetModule('Github');
		Info = RepoInfo(Repo, Owner, Target);
		Path = Mod.GetRepoPath(this, Info);

		if (!Direct.Exists(Path)) {
			Direct.CreateDirectory(Path);
		}
		
		Commits = Mod.PollCommits(Info.Owner, Info.Name, Info.AccessToken);
		Issues = Mod.PollIssues(Info.Owner, Info.Name, Info.AccessToken);

		Latest = Commits[0];

		if (Latest) {
			Info.LastKnownSha = Latest.sha;
			this.SendMessage(Repo.Channel, Latest.Template(Mod.CommitTemplate));
		}

		Commits.Save(Path + 'Commits.json');
		Issues.Save(Path + 'Issues.json');

		this.GithubConfig + Info.ToObject();
		Mod.SaveConfig(this);
	}
}